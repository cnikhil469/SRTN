<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SRTN Scheduling with Quantum</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
      }
      table,
      th,
      td {
        border: 1px solid black;
      }
      th,
      td {
        padding: 8px;
        text-align: center;
      }
      input {
        width: 80px;
      }
      canvas {
        margin-top: 20px;
      }
      #summary {
        margin-top: 20px;
        font-size: 1.1em;
      }
    </style>
  </head>
  <body>
    <h1>SRTN Scheduling with Quantum</h1>

    <label for="cpuCount">Number of CPUs: </label>
    <input type="number" id="cpuCount" value="2" min="1" />
    <br /><br />

    <label for="quantum">Quantum Time: </label>
    <input type="number" id="quantum" value="1" min="1" />
    <br /><br />

    <button onclick="addJob()">Add Jobs</button>
    <button onclick="removeLastJob()">Remove Last Job</button>
    <button onclick="calculateSRTN()">Calculate SRTN</button>
    <br /><br />

    <table>
      <thead>
        <tr>
          <th>#Jobs</th>
          <th>Arrival Time</th>
          <th>Burst Time</th>
          <th>Start Time</th>
          <th>End Time</th>
          <th>Turnaround Time</th>
        </tr>
      </thead>
      <tbody id="jobTable">
        <!-- Job rows will be dynamically added here -->
      </tbody>
    </table>

    <h3>Total Turnaround Time: <span id="totalTurnaround">0</span></h3>

    <canvas id="ganttChart" width="1800" height="1000"></canvas>

    <div id="summary">
      <h3>Final Summary of Start Times</h3>
      <ul id="startTimesList">
        <!-- Summary of start and end times will be added here -->
      </ul>
    </div>

    <script>
      let jobCounter = 0;
      let jobs = [];

      // Function to add a job row
      function addJob() {
        jobCounter++;
        const table = document.getElementById("jobTable");
        const row = document.createElement("tr");
        row.id = `jobRow${jobCounter}`;
        row.innerHTML = `
                <td>Job ${jobCounter}</td>
                <td><input type="number" id="arrivalTime${jobCounter}" min="0" placeholder="Arrival time"></td>
                <td><input type="number" id="burstTime${jobCounter}" min="1" placeholder="Burst time"></td>
                <td id="startTime${jobCounter}">-</td>
                <td id="endTime${jobCounter}">-</td>
                <td id="turnaroundTime${jobCounter}">-</td>
            `;
        table.appendChild(row);
      }

      // Function to remove the last job row
      function removeLastJob() {
        if (jobCounter > 0) {
          const row = document.getElementById(`jobRow${jobCounter}`);
          row.remove();
          jobCounter--;
        }
      }

      // Function to calculate SRTN with quantum
      function calculateSRTN() {
        let jobs = [];
        for (let i = 1; i <= jobCounter; i++) {
          const arrivalTime = parseInt(
            document.getElementById(`arrivalTime${i}`).value
          );
          const burstTime = parseInt(
            document.getElementById(`burstTime${i}`).value
          );
          jobs.push({
            job: i,
            arrivalTime,
            burstTime,
            remainingTime: burstTime,
            startTime: null,
            endTime: null,
            currentCpuRunTime: arrivalTime,
            cpuIds: [],
          });
        }
        const numCPUs = parseInt(document.getElementById("cpuCount").value);
        const quantum = parseInt(document.getElementById("quantum").value);
        console.log("jobs at cal", jobs);

        performSRTN(jobs, numCPUs, quantum);
      }
      function isSameJob(item1, item2) {
        return (
          item1.job === item2.job &&
          item1.startTime === item2.startTime &&
          item1.duration === item2.duration &&
          item1.cpu === item2.cpu
        );
      }

      // Shortest Remaining Time Next (SRTN) Algorithm with Quantum
      function performSRTN(jobs, numCPUs, quantum) {
        let currentTime = 0;
        let totalTurnaround = 0;
        let completedJobs = [];
        const schedule = [];
        let CPU_List = [];
        for (let i = 0; i < numCPUs; i++) {
          CPU_List.push({
            cpuID: i + 1,
            isRunning: false,
            jobId: 0,
            switchTime: 0,
          });
        }

        let jobsOriginalList = jobs;
        const sortJobs = (jobs, currentTime) => {
          const availableJobs = jobs.filter(
            (job) => job.arrivalTime <= currentTime
          );
          availableJobs.sort((a, b) => {
            if (a.remainingTime !== b.remainingTime) {
              return a.remainingTime - b.remainingTime;
            }
            return a.arrivalTime - b.arrivalTime;
          });

          return availableJobs;
        };
        const removeJob = (jobs, currentJob) => {
          return jobs.filter((job) => job.job !== currentJob.job);
        };
        let i = 0;
        let j = 0;
        let currentJob;
        let currentCPU;
        let currentCPUJobs = [];
        let newJobs = sortJobs(jobs, 0);
        console.log("newJobs", newJobs);

        while (completedJobs.length < jobsOriginalList.length) {
          console.log("i", i);
          console.log("j", j);
          if (i == CPU_List.length || j == newJobs.length) {
            i = 0;
            currentTime = currentTime + quantum;
            j = 0;
            console.log("jobs at starting if condition", jobs);
            newJobs = sortJobs(jobs, currentTime);
            console.log("currentTime", currentTime);
          }

          while (newJobs.length == 0) {
            currentTime = currentTime + quantum;
            newJobs = sortJobs(jobs, currentTime);
            console.log("currentTime", currentTime);
          }
          console.log("the jobs list", newJobs);
          let currentJob = newJobs[j];
          let currentCPU = CPU_List[i];
          console.log("currentJob", currentJob);
          console.log("currentCPU", currentCPU);
          if (
            currentJob &&
            currentJob.arrivalTime <= currentTime &&
            currentJob.endTime == null &&
            currentJob.currentCpuRunTime <= currentTime &&
            currentCPU.switchTime <= currentTime &&
            currentTime % quantum == 0
          ) {
            currentJob.cpuIds.push(currentCPU.cpuID);
            console.log("the current time inside while", currentTime);
            console.log("current running job in cpu", currentJob);
            lowerTime = Math.min(quantum, currentJob.remainingTime);
            currentCPU.isRunning = true;
            currentCPU.jobId = currentJob.job;
            if (currentJob.startTime == null) {
              currentJob.startTime = currentTime;
            }
            currentJob.remainingTime = currentJob.remainingTime - lowerTime;
            currentCPU.switchTime = currentTime + lowerTime;
            currentJob.currentCpuRunTime = currentTime + lowerTime;

            const jobExists = schedule.some((item) =>
              isSameJob(item, {
                job: currentJob.job,
                startTime: currentTime,
                duration: currentJob.currentCpuRunTime,
                cpu: i + 1,
                arrivalTime: currentJob.arrivalTime,
              })
            );

            if (!jobExists) {
              // If the exact item is not present, add it to the schedule
              schedule.push({
                job: currentJob.job,
                startTime: currentTime,
                duration: currentJob.currentCpuRunTime,
                cpu: i + 1,
                arrivalTime: currentJob.arrivalTime,
              });
            }
          }
          if (
            currentJob &&
            currentJob.remainingTime == 0 &&
            !completedJobs.includes(currentJob)
          ) {
            currentJob.endTime = currentJob.currentCpuRunTime;
            completedJobs.push(currentJob);
            console.log("jobs before deletion", jobs);
            jobs = removeJob(jobs, currentJob);
            console.log("job to be deleted", currentJob);
            console.log("jobs after deletion", jobs);
            const turnaroundTime = currentJob.endTime - currentJob.arrivalTime;
            totalTurnaround += turnaroundTime;
            document.getElementById(`endTime${currentJob.job}`).textContent =
              currentJob.endTime;
            document.getElementById(
              `turnaroundTime${currentJob.job}`
            ).textContent = turnaroundTime;
            // jobs.splice(j, 1); need to find the index of job j in jobs.
          }
          if (currentJob && currentJob.currentCpuRunTime > currentTime) {
            j = j + 1;
          }
          if (
            (currentCPU && currentCPU.switchTime > currentTime) ||
            j == newJobs.length
          ) {
            i = i + 1;
          }
          document.getElementById(`startTime${currentJob.job}`).textContent =
            currentJob.startTime;
          updateSummary(
            currentJob.job,
            currentJob.startTime,
            currentJob.currentCpuRunTime
          );
        }
        console.log("completedJobs", completedJobs);
        document.getElementById("totalTurnaround").textContent = (
          totalTurnaround / jobsOriginalList.length
        ).toFixed(2);
        drawGanttChart(schedule, numCPUs, quantum);
      }

      // Function to update the summary of start and end times
      function updateSummary(job, startTime, endTime) {
        const summaryList = document.getElementById("startTimesList");
        const listItem = document.createElement("li");
        listItem.textContent = `Job ${job}: Starts at time ${startTime}, finishes at time ${endTime}.`;
        summaryList.appendChild(listItem);
      }
      // drawgantt chart
      function drawGanttChart(schedule, numCPUs, quantum) {
        console.log("schedule", schedule);

        const canvas = document.getElementById("ganttChart");
        const ctx = canvas.getContext("2d");

        // Fixed set of colors to assign to jobs, using job ID for consistency
        const colors = [
          "#f4a582",
          "#fdcc8a",
          "#d73027",
          "#4575b4",
          "#4a6741",
          "#cd5c5c",
          "#c2c5f9",
          "#4acb22",
          "#cf1133",
          "#14375c",
          "#7fffd4",
          "#675a99",
          "#b0cde4",
          "#2e6298",
        ];

        function getJobColor(jobID) {
          return colors[jobID % colors.length];
        }

        const cpuHeight = 50; // Height for each CPU row
        const jobHeight = 30; // Height of job bars
        const padding = 10; // Padding inside the job bars
        const labelWidth = 80; // Space for CPU labels on the left side
        const labelChartSpacing = 20; // Additional space between the label and the chart
        const jobArrivalSpace = 100; // Extra space above CPU1 for job arrivals

        // Calculate total time based on the end time of jobs
        const totalTime =
          Math.max(
            ...schedule.map(
              (job) => job.startTime + (job.duration - job.startTime)
            )
          ) + 1;

        // Set minimum and maximum limits for time unit width
        const maxCanvasWidth = 1000; // Maximum canvas width
        const minTimeUnitWidth = 20; // Minimum width for each time unit
        const timeUnitWidth = Math.max(
          Math.min(maxCanvasWidth / totalTime, 50),
          minTimeUnitWidth
        );

        // Adjust the canvas width based on total time and timeUnitWidth
        canvas.width =
          totalTime * timeUnitWidth + labelWidth + labelChartSpacing;

        // Increase canvas height to fit job arrivals above CPU1
        canvas.height = numCPUs * cpuHeight + padding * 2 + jobArrivalSpace;

        // Draw CPU labels on the left side
        for (let i = 0; i < numCPUs; i++) {
          const y = i * cpuHeight + padding + jobArrivalSpace;
          ctx.fillStyle = "#000";
          ctx.font = "14px Arial";
          ctx.fillText(`CPU-${i + 1}`, labelWidth / 2, y + jobHeight / 2 + 5);
        }

        // Draw the job bars
        schedule.forEach((job) => {
          const cpuIndex = job.cpu - 1; // CPU index (0-based)
          const startX =
            job.startTime * timeUnitWidth + labelWidth + labelChartSpacing;
          const width = (job.duration - job.startTime) * timeUnitWidth; // Correct job duration width
          const y = cpuIndex * cpuHeight + padding + jobArrivalSpace;

          const color = getJobColor(job.job);

          // Draw the job as a rectangle
          ctx.fillStyle = color;
          ctx.fillRect(startX, y, width, jobHeight);

          // Draw the job label inside the bar
          ctx.fillStyle = "#000";
          ctx.font = "14px Arial";
          ctx.fillText(`J${job.job}`, startX + padding, y + jobHeight / 2 + 5);
        });

        // Draw time labels and vertical lines on the X-axis based on quantum and job arrivals
        let intervalCount = 3;
        let intervalStep = quantum / intervalCount;

        const uniqueArrivalTimes = new Set(
          schedule.map((job) => job.arrivalTime)
        );
        const jobEndTimes = [...new Set(schedule.map((job) => job.duration))];

        const arrowY = 10; // Y position for arrow (Above CPU1)
        const labelYSpacing = 30; // Spacing between labels

        for (let t = 0; t <= totalTime; t++) {
          const x = t * timeUnitWidth + labelWidth + labelChartSpacing;
          const y = numCPUs * cpuHeight + jobArrivalSpace;

          if (
            t % intervalStep === 0 ||
            jobEndTimes.includes(t) ||
            uniqueArrivalTimes.has(t)
          ) {
            ctx.fillStyle = "#000";
            ctx.fillText(`${t}`, x, y + 20);

            ctx.beginPath();
            ctx.moveTo(x, jobArrivalSpace); // Start line after job arrivals
            ctx.lineTo(x, y);
            ctx.strokeStyle = "#000";
            ctx.stroke();
          }

          const jobsArrivingAtT = schedule.filter(
            (job) =>
              uniqueArrivalTimes.has(job.arrivalTime) && job.arrivalTime === t
          );

          if (jobsArrivingAtT.length > 0) {
            // Group jobs by their arrival time and job ID to prevent duplicates
            const groupedJobs = jobsArrivingAtT.reduce((acc, job) => {
              const key = `${job.arrivalTime}-${job.job}`;
              if (!acc[key]) {
                acc[key] = job;
              }
              return acc;
            }, {});
            let spaceVertical = 0;
            // Draw a single downward arrow for each group
            for (const key in groupedJobs) {
              const job = groupedJobs[key];

              ctx.beginPath();
              ctx.moveTo(x, arrowY); // Arrow start point
              ctx.lineTo(x - 5, arrowY - 10); // Left diagonal (up)
              ctx.lineTo(x + 5, arrowY - 10); // Right diagonal (up)
              ctx.closePath();
              ctx.fillStyle = "#000";
              ctx.fill();

              // Draw job label vertically beside the arrow
              ctx.fillStyle = "#000";
              ctx.font = "12px Arial";
              ctx.fillText(
                `J${job.job}`,
                x - 6,
                arrowY + labelYSpacing + spaceVertical
              );
              spaceVertical = spaceVertical + 20;
            }
          }
        }
      }
    </script>
  </body>
</html>
